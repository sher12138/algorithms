# 线性时间排序

比较排序： 通过比较来决定元素的相对次序。{归并、堆、快排}  <-- 最坏情况下时间复杂度为 O(nlogn)
比较排序，要求 yi > / <  =  yj  取其一，但如果元素不等，不需要 = ，同时 > < 可以同化为 ai<=aj 形式 
于是一切比较排序都可以转换为*决策树*，任意一个到叶子节点平凡路径都是一个可行排列，

每个到叶子结点的平凡路径都是一种不同的排列方式。
输入数据最多 n! 种排列方式,
n! < l < 2^n 

## 1.1 计数排序：稳定
已知数据范围，可以使用计数排序，时间复杂度为O(n+k)，空间复杂度为O(n+k)。
统计每个元素出现的次数，然后进行累加，然后将元素放到对应的位置上。

```python
def countint_sort(A):
    n = len(A)
    k = max(A)
    C = [0] * (k+1)
    B = [0] * n
    for i in range(n):
        C[A[i]] += 1  # 计数 
    for i in range(1, k+1):
        C[i] += C[i-1]  # 累加元素数 
    for i in range(n-1, -1, -1): # 逆序遍历，保证稳定性
        B[C[A[i]]-1] = A[i]
        C[A[i]] -= 1  # 每排序一个，递减元素数 
    return B
```

