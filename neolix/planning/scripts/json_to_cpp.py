#!/usr/bin/python
from __future__ import print_function

import os
import sys
import json
import shutil
import filecmp

file_comments = """/**
 * @brief this file is auto-generated by scripts/json_to_cpp.py. Do not edit!!!
 */
"""
cpp_str = ""

def parse_var_header(var_type, key):
  return var_type+" "+key.lower()+";\n"

def parse_list_header(struct_name_prefix, prefix, json_val):
  # print("================================")
  # print("parse_list_header: ", prefix, json_val)
  if (len(json_val) <=0):
    return
  list_val_type = type(json_val[0])
  # print(val_type)
  if list_val_type == dict:
    struct_name = prefix.replace('_', ' ').title().replace(' ', '')
    include_line = "  struct  "+struct_name+" {\n"
    # print(include_line)
    struct_str = include_line
    index = 0
    map_key_type = ""
    for key in json_val[0].keys():
      val_type = type(json_val[0][key])
      if index == 0:
        map_key_type = val_type
      index += 1
      if val_type == str:
        struct_str += parse_var_header("std::string", key)
      elif val_type == bool:
        struct_str += parse_var_header("bool", key)
      elif val_type == int:
        struct_str += parse_var_header("int", key)
      elif val_type == float:
        struct_str += parse_var_header("float", key)
      elif val_type == dict:
        new_struct_str = parse_dict_header(prefix+"."+key, json_val[0][key])
        struct_str += new_struct_str
      else:
        print("================ ERROR type: ", val_type)
        return
    struct_str += "  };\n"
    if map_key_type == str:
      struct_str += "  std::unordered_map<std::string, "+struct_name+">"+prefix.lower()+";\n"
    else:
      struct_str += "  std::vector<"+struct_name+">"+prefix.lower()+";\n"
    # print("parse_list_header done: struct_str: ", struct_str)
    return struct_str
  else:
    vector_name = prefix.lower()
    vector_str = "std::vector<"
    # print(json_val)
    val_type = type(json_val[0])
    if val_type == str:
      vector_str += "std::string"
    elif val_type == bool:
      vector_str += "bool"
    elif val_type == int:
      vector_str += "int"
    elif val_type == float:
      vector_str += "float"
    vector_str += ">  "+vector_name+";\n"
    return vector_str

def parse_dict_header(prefix, json_val):
  # print("================================")
  # print("parse_dict_header: ", prefix, json_val.keys())
  struct_str = "" 
  if len(prefix) > 0:
    struct_name = prefix.replace('_', ' ').title().replace(' ', '')
    include_line = "  struct  "+struct_name.split(".")[-1]+" {\n"
    # print(include_line)
    struct_str += include_line
  for key in json_val.keys():
    val_type = type(json_val[key])
    if val_type == str:
      struct_str += parse_var_header("std::string", key)
    elif val_type == bool:
      struct_str += parse_var_header("bool", key)
    elif val_type == int:
      struct_str += parse_var_header("int", key)
    elif val_type == float:
      struct_str += parse_var_header("float", key)
    elif val_type == list:
      new_struct_str = parse_list_header(struct_name, key, json_val[key])
      struct_str += new_struct_str
    elif val_type == dict:
      new_struct_str = parse_dict_header(prefix+"."+key, json_val[key])
      struct_str += new_struct_str
    else:
      print("================ ERROR type: ", val_type)
      return
  if len(prefix) > 0:
    struct_str += "  };\n"
    struct_str += "  "+struct_name.split(".")[-1]+" "+prefix.split(".")[-1]+";\n"
  # print("parse_dict_header done: struct_str: ", struct_str)
  return struct_str

def generate_header(input_file, output_dir, namespace_key):
  if not os.path.exists(input_file):
    print(input_file," not exist!!!")
    return
  file_name = "auto_"+os.path.splitext(input_file.split("/")[-1])[0]
  struct_name = file_name.replace('_', ' ').title().replace(' ', '')
  # print(struct_name)
  header_str = file_comments+"\n\n"
  header_str += "#pragma once\n\n"
  header_str += "#include <string>\n"
  header_str += "#include <vector>\n"
  header_str += "#include <unordered_map>\n"
  header_str += "#include <jsoncpp/json/json.h>\n\n"
  header_str += "namespace neodrive {\n"
  header_str += "namespace "+namespace_key+"{\n"
  header_str += "namespace config {\n\n"
  struct_str = ""
  struct_str += "struct "+struct_name+" {\n"
  with open(input_file, 'r') as f:
    input_json = json.load(f)
    # print(input_json.keys())
    for key in input_json.keys():
      val_type = type(input_json[key])
      # print(key, val_type, input_json[key].__class__, input_json[key])
      if (val_type == dict):
        new_struct_str = parse_dict_header(key, input_json[key])
        struct_str += new_struct_str
      elif val_type == list:
        new_struct_str = parse_list_header(struct_name, key, input_json[key])
        struct_str += new_struct_str
      elif val_type == str:
        struct_str += parse_var_header("std::string", key)
      elif val_type == bool:
        struct_str += parse_var_header("bool", key)
      elif val_type == int:
        struct_str += parse_var_header("int", key)
      elif val_type == float:
        struct_str += parse_var_header("float", key)
      else:
        print("================ ERROR type: ", val_type)
        return
  struct_str += "};\n\n"
  header_str += struct_str
  header_str += "void Init"+struct_name+"(const Json::Value &input_json, "+struct_name+" &dest);\n\n"
  header_str += "}  // namespace config\n"
  header_str += "}  // namespace "+namespace_key+"\n"
  header_str += "}  // namespace neodrive\n"
  output_file = output_dir+"/"+file_name+".h"
  tmp_output_file = output_dir+"/tmp_"+file_name+".h"
  with open(tmp_output_file, 'w') as f:
    f.write(header_str)
  cmd = "/usr/bin/clang-format -style=Google -i " + tmp_output_file
  # print(cmd)
  result = os.system(cmd)
  if not os.path.exists(output_file):
    print("generate new file:", output_file)
    shutil.move(tmp_output_file, output_file)
  elif not filecmp.cmp(tmp_output_file, output_file):
    print("generate new file:", output_file)
    shutil.move(tmp_output_file, output_file)
  else:
    os.remove(tmp_output_file)

def parse_var_cpp(prefix, key, out_put_prefix, json_func_name):
  cpp_line = ""
  if len(prefix) == 0:
    cpp_line = "  dest." + key.lower() +" = "+ out_put_prefix+"[\""+key+"\"]."+json_func_name+"();\n"
  else:
    cpp_line = "  dest." + (prefix+"."+key).lower() +" = "+ out_put_prefix+"[\""+key+"\"]."+json_func_name+"();\n"
  return cpp_line

def parse_dict_cpp(prefix, json_val, out_put_prefix):
  global cpp_str
  # print("================================")
  # print("parse_dict_cpp: ", prefix, out_put_prefix)
  # print(json_val.keys())
  if len(prefix) > 0:
    struct_name = prefix.replace('_', ' ').title().replace(' ', '')
  for key in json_val.keys():
    val_type = type(json_val[key])
    if val_type == str:
      cpp_str += parse_var_cpp(prefix, key, out_put_prefix, "asString")
    elif val_type == bool:
      cpp_str += parse_var_cpp(prefix, key, out_put_prefix, "asBool")
    elif val_type == int:
      cpp_str += parse_var_cpp(prefix, key, out_put_prefix, "asInt")
    elif val_type == float:
      cpp_str += parse_var_cpp(prefix, key, out_put_prefix, "asDouble")
    elif val_type == list:
      # print(prefix, key, json_val[key], out_put_prefix+"[\""+key+"\"]")
      parse_list_cpp(prefix, key, json_val[key], out_put_prefix+"[\""+key+"\"]")
    elif val_type == dict:
      parse_dict_cpp(prefix+"."+key, json_val[key], out_put_prefix+"[\""+key+"\"]")
    else:
      print("================ ERROR type: ", val_type)
      return

def parse_list_var_cpp(prefix, key, out_put_prefix, json_func_name):
  cpp_line = prefix.lower()+"."+key.lower() +"="+ out_put_prefix+"[\""+key+"\"]."+json_func_name+"();\n"
  return cpp_line

def parse_list_dict_var_cpp(prefix, json_val, out_put_prefix):
  # cpp_line = prefix+"."+key.lower() +"="+ out_put_prefix+"[\""+key+"\"]."+json_func_name+"();\n"
  global cpp_str
  # print("================================")
  # print("parse_list_dict_var_cpp: ", prefix, out_put_prefix)
  # print(json_val.keys())
  if len(prefix) > 0:
    struct_name = prefix.replace('_', ' ').title().replace(' ', '')
  for key in json_val.keys():
    val_type = type(json_val[key])
    if val_type == str:
      cpp_str += parse_list_var_cpp(prefix, key, out_put_prefix, "asString")
    elif val_type == bool:
      cpp_str += parse_list_var_cpp(prefix, key, out_put_prefix, "asBool")
    elif val_type == int:
      cpp_str += parse_list_var_cpp(prefix, key, out_put_prefix, "asInt")
    elif val_type == float:
      cpp_str += parse_list_var_cpp(prefix, key, out_put_prefix, "asDouble")
    # elif val_type == list:
    #   parse_list_cpp(struct_name+"::"+key, json_val[key], out_put_prefix+"[\""+key+"\"]")
    # elif val_type == dict:
    #   parse_dict_cpp(prefix+"."+key, json_val[key], out_put_prefix+"[\""+key+"\"]")
    else:
      print("================ ERROR type: ", val_type)
      return


def parse_list_cpp(struct_prefix, prefix, json_val, out_put_prefix):
  global cpp_str
  # print("================================")
  # print("parse_list_cpp: ", prefix, out_put_prefix)
  if (len(json_val) <=0):
    return
  struct_name_prefix = struct_prefix.replace('_', ' ').title().replace(' ', '')
  struct_name = prefix.replace('_', ' ').title().replace(' ', '')
  list_var_type = type(json_val[0])
  if list_var_type == dict:
    cpp_str += "  dest."+prefix.lower()+".clear();\n"
    cpp_str += "for (const auto &config_dict : "+out_put_prefix+") {\n"
    cpp_str += struct_name_prefix+"::"+struct_name+" curr_config{};\n"
    map_key= ""
    map_key_type = ""
    index = 0
    for key in json_val[0].keys():
      key_type = type(key)
      val_type = type(json_val[0][key])
      if index == 0:
        map_key = key
        map_key_type = val_type
      index += 1
      if val_type == str:
        cpp_str += parse_list_var_cpp("curr_config", key, "config_dict", "asString")
      elif val_type == bool:
        cpp_str += parse_list_var_cpp("curr_config", key, "config_dict", "asBool")
      elif val_type == int:
        cpp_str += parse_list_var_cpp("curr_config", key, "config_dict", "asInt")
      elif val_type == float:
        cpp_str += parse_list_var_cpp("curr_config", key, "config_dict", "asDouble")
      elif val_type == dict:
        parse_list_dict_var_cpp("curr_config."+key, json_val[0][key], "config_dict[\""+key+"\"]")
      else:
        print("================ ERROR type: ", val_type)
        return
    if map_key_type == str:
      cpp_str += "  dest."+prefix.lower()+".insert({curr_config."+map_key+", curr_config});\n"
    else:
      cpp_str += "  dest."+prefix.lower()+".emplace_back(curr_config);\n"
    cpp_str += "}\n"
  else:
    vector_name = prefix.lower()
    vector_str = "std::vector<"
    # print(json_val)
    cpp_str += "  dest."+struct_prefix.lower()+"."+prefix.lower()+".clear();\n"
    cpp_str += "for (const auto &curr_config : "+out_put_prefix+") {\n"
    cpp_str += "  dest."+struct_prefix.lower()+"."+prefix.lower()+".push_back(curr_config."; 
    val_type = type(json_val[0])
    if val_type == str:
      cpp_str += "asString());"
    elif val_type == bool:
      cpp_str +=  "asBool());"
    elif val_type == int:
      cpp_str +=  "asInt());"
    elif val_type == float:
      cpp_str +=  "asDouble());"
    else:
      print("================ ERROR type: ", val_type)
      return
    cpp_str += "}\n"
    return cpp_str


def generate_cpp(input_file, output_dir, namespace_key):
  global cpp_str
  cpp_str = ""
  if not os.path.exists(input_file):
    print(input_file," not exist!!!")
    return
  file_name = "auto_"+os.path.splitext(input_file.split("/")[-1])[0]
  struct_name = file_name.replace('_', ' ').title().replace(' ', '')
  # print(struct_name)
  cpp_str += file_comments+"\n\n"
  cpp_str += "#include \"config/"+file_name+".h\"\n\n"
  cpp_str += "namespace neodrive {\n"
  cpp_str += "namespace "+namespace_key+"{\n"
  cpp_str += "namespace config {\n\n"
  cpp_str += "void Init"+struct_name+"(const Json::Value &input_json, "+struct_name+" &dest) {\n"
  with open(input_file, 'r') as f:
    input_json = json.load(f)
    # print(input_json.keys())
    for key in input_json.keys():
      val_type = type(input_json[key])
      # print(key, val_type, input_json[key].__class__, input_json[key])
      out_put_prefix = "input_json[\""+key+"\"]"
      if (val_type == dict):
        parse_dict_cpp(key, input_json[key], out_put_prefix)
      elif val_type == list:
        parse_list_cpp(file_name, key, input_json[key], out_put_prefix)
      elif val_type == str:
        cpp_str += parse_var_cpp("", key, "input_json", "asString")
      elif val_type == bool:
        cpp_str += parse_var_cpp("", key, "input_json", "asBool")
      elif val_type == int:
        cpp_str += parse_var_cpp("", key, "input_json", "asInt")
      elif val_type == float:
        cpp_str += parse_var_cpp("", key, "input_json", "asDouble")
      else:
        print("================ ERROR type: ", val_type)
        return
  cpp_str += "}\n\n"
  cpp_str += "}  // namespace config\n"
  cpp_str += "}  // namespace "+namespace_key+"\n"
  cpp_str += "}  // namespace neodrive\n"
  output_file = output_dir+"/"+file_name+".cpp"
  tmp_output_file = output_dir+"/tmp_"+file_name+".cpp"
  with open(tmp_output_file, 'w') as f:
    f.write(cpp_str)
  cmd = "/usr/bin/clang-format -style=Google -i " + tmp_output_file
  # print(cmd)
  result = os.system(cmd)
  if not os.path.exists(output_file):
    print("generate new file:", output_file)
    shutil.move(tmp_output_file, output_file)
  elif not filecmp.cmp(tmp_output_file, output_file):
    print("generate new file:", output_file)
    shutil.move(tmp_output_file, output_file)
  else:
    os.remove(tmp_output_file)

if __name__ == "__main__":
  if len(sys.argv) < 4:
    print("json_to_cpp.py input_json_file out_put_files_folder namespace")
  if os.path.isdir(sys.argv[1]):
    files = os.listdir(sys.argv[1])
    for file_name in files:
      if ".json" == file_name[-5:]:
        generate_header(os.path.join(sys.argv[1],file_name), sys.argv[2], sys.argv[3])
        generate_cpp(os.path.join(sys.argv[1],file_name), sys.argv[2], sys.argv[3])
  else:
    generate_header(sys.argv[1], sys.argv[2], sys.argv[3])
    generate_cpp(sys.argv[1], sys.argv[2], sys.argv[3])
    